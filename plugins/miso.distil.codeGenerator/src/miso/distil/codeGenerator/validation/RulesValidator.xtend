/*
 * generated by Xtext
 */
package miso.distil.codeGenerator.validation

import org.eclipse.xtext.validation.Check
import codeGeneratorModel.CodeGeneratorModelPackage
import codeGeneratorModel.AbstractEntity
import codeGeneratorModel.Attribute
import codeGeneratorModel.Entity
import codeGeneratorModel.Root
import codeGeneratorModel.Artifact
import codeGeneratorModel.Reference
import java.util.List
import java.util.ArrayList
import codeGeneratorModel.Service
import org.eclipse.emf.common.util.EList
import codeGeneratorModel.MultiService
import codeGeneratorModel.SimpleService
import org.eclipse.emf.common.util.BasicEList
import codeGeneratorModel.OnService
import codeGeneratorModel.ServiceEnum
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import com.google.inject.Inject
import java.util.Scanner
import codeGeneratorModel.Inout

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * @author Carlos Carrascal
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class RulesValidator extends AbstractRulesValidator {

	public static val LOWER_CASE = 'lowerCase' //
	public static val UPPER_CASE = 'upperCase' //
  	public static val REPEATED_NAME = 'repeatedName'
  	public static val INPUT_WRONG = 'wrongInput'
  	public static val PROHIBITED_NAME= 'prohibitedName'
  	public static val PROHIBITED_REFERENCE= 'prohibitedReference' //
  	public static val RECURSIVE_REFERENCE= 'recursiveReference'
  	public static val ARTIFACT_TODO = 'artifactToDo'
  	public static val SERVICE_TODO = 'serviceToDo'
  	public static val EMPTY_MONGO_URI = 'emptyMongoURI'
  	
  	@Inject 
	private miso.distil.codeGenerator.generator.Names names
  	
	@Check
	// Los OnService deben referenciar artifacts que tengan, al menos, los servicios definidos en whenServices
	def chechOnService(OnService onSer) {
		onSer.whenServices.forEach[
			if(onSer.artifact.basicServices != null) {
				if(!onSer.artifact.basicServices.contains(it) && !onSer.artifact.basicServices.contains(ServiceEnum.ALL)) {
					error(' Artifact ' + onSer.artifact.name + ' does not have service ' + it.toString + ' enabled',
						CodeGeneratorModelPackage.Literals.ON_SERVICE__WHEN_SERVICES,
						PROHIBITED_REFERENCE)
				}
			}
		]
	}

	@Check
	// Las entitys no pueden estar encadenadas recursivamente
	def checkReferenceNotRecursive(Entity ent) {
		for(Attribute att : ent.attributes) {
			if(att instanceof Reference) {
				if(att.type.attributes.lookForRepeated(ent.name)) {
					error('This entity contains ' + att.name + ', who contains this entity',
						CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME,
						RECURSIVE_REFERENCE)
				}
			}
		}
	}
	
	def private Boolean lookForRepeated(EList<Attribute> atts, String name) {
		for(Attribute att : atts) {
			if(att instanceof Reference) {
				if(att.type.name.equalsIgnoreCase(name)) {
					return true;
				} else {
					if(att.type.attributes.lookForRepeated(name)) {
						return true;
					}
				}
			}
		}
		return false;
	}

	@Check
	// Los servicios de un MultiService deben tener entradas y salidas exactas
	def checkMultiServiceParameters(MultiService mulSer) {
		if(!mulSer.parallel && !mulSer.services.empty) {
			var EList<Inout> out = (mulSer.services.get(0) as Service).output
			for(var int j = 1; j < mulSer.services.size; j++) {
				var service = (mulSer.services as EList<Service>).get(j)
				
				if(out.size != service.getInput.size) {
					error('Service ' + service.name + ' requires ' + service.getInput.size + ' inputs but receives ' + out.size + ' from ' + (mulSer.services as EList<Service>).get(j-1).name, 
							CodeGeneratorModelPackage.Literals.MULTI_SERVICE__SERVICES,
							INPUT_WRONG)
				}
				
				for(var int i = 0; i<service.getInput.size; i++) {
					if(!out.get(i).type.equals(service.getInput.get(i).type) || !out.get(i).many.equals(service.getInput.get(i).many)) {
						error('Input ' + i + ' of service ' + service.name + ' requires ' + service.getInput.get(i).type.name + ' and many ' + service.getInput.get(i).many + ' but ' + out.get(i).type.name + ' with many ' + out.get(i).many + ' given', 
							CodeGeneratorModelPackage.Literals.MULTI_SERVICE__SERVICES,
							INPUT_WRONG)
					}
				}
				out = service.getOutput
			}
		}
	}
	
	private def EList<Inout> getInput(Service service) {
		if(service instanceof SimpleService) {
			return service.input
		}
		else if(service instanceof MultiService) {
			if(service.parallel) {
				var EList<Inout> input = new BasicEList<Inout>()
				for(ser : service.services as EList<Service>) {
					input.addAll(ser.getInput)
				}
				return input
			} else {
				return (service.services.get(0) as Service).getInput
			}
		}
	}
	
	private def EList<Inout> getOutput(Service service) {
		if(service instanceof SimpleService) {
			return service.output
		}
		else if(service instanceof MultiService) {
			if(service.parallel) {
				var EList<Inout> output = new BasicEList<Inout>()
				for(ser : service.services as EList<Service>) {
					output.addAll(ser.getOutput)
				}
				return output
			} else {
				return (service.services.last as Service).getOutput
			}
		}
	}

	@Check
	// Las clases deben comenzar por mayuscula
	def checkEntityStartsWithCapital(AbstractEntity ent) {	
		if (!Character.isUpperCase(ent.name.charAt(0))) {
			error('Identifier should start with a capital', 
				CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME,
				UPPER_CASE)
		}
	}
	
	@Check
	// Los atributos deben ser en minuscula
	def checkAttributeLowerCase(Attribute att) {
		for(var i=0; i<att.name.length; i++) {
			if (!Character.isLowerCase(att.name.charAt(i))) {
				error('This name has to be lower case', 
					CodeGeneratorModelPackage.Literals.ATTRIBUTE__NAME,
					LOWER_CASE)
				return;
			}
		}
	}
	
	@Check
	// Los servicios deben comenzar por mayuscula
	def checkServiceStartsWithCapital(Service ser) {	
		if (!Character.isUpperCase(ser.name.charAt(0))) {
			error('Identifier should start with a capital', 
				CodeGeneratorModelPackage.Literals.SERVICE__NAME,
				UPPER_CASE)
		}
	}
	
	@Check
	// Todos los nombres deben ser unicos
	def checkUniqueNames(Root root) {
		val List<String> names = new ArrayList<String>()
		
		(root.artifacts as EList<Artifact>).forEach[
			if(names.contains(it.name.toLowerCase)) {
				error('Name ' + it.name + ' is repeated',
					it,
					CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME,
					REPEATED_NAME)
			} else {
				names.add(it.name.toLowerCase)
			}
			
			(it.attributes as EList<Attribute>).forEach[
				if(names.contains(it.name.toLowerCase)) {
					error('Name ' + it.name + ' is repeated',
					it,
						CodeGeneratorModelPackage.Literals.ATTRIBUTE__NAME,
						REPEATED_NAME)
				} else {
					names.add(it.name.toLowerCase)
				}
			]
		]
		
		(root.entities as EList<Entity>).forEach[
			if(names.contains(it.name.toLowerCase)) {
				error('Name ' + it.name + ' is repeated',
					it,
					CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME,
					REPEATED_NAME)
			} else {
				names.add(it.name.toLowerCase)
			}
			
			(it.attributes as EList<Attribute>).forEach[
				if(names.contains(it.name.toLowerCase)) {
					error('Name ' + it.name + ' is repeated',
					it,
						CodeGeneratorModelPackage.Literals.ATTRIBUTE__NAME,
						REPEATED_NAME)
				} else {
					names.add(it.name.toLowerCase)
				}
			]
		]
		
		(root.services as EList<Service>).forEach[
			if(names.contains(it.name.toLowerCase)) {
				error('Name ' + it.name + ' is repeated',
					it,
					CodeGeneratorModelPackage.Literals.SERVICE__NAME,
					REPEATED_NAME)
			} else {
				names.add(it.name.toLowerCase)
			}
		]
			
	}
	
	@Check
	// Las clases no pueden tener ciertos nombres que ya se usan durante la generacion de codigo
	def checkNamesEntityNotProhibited(AbstractEntity ent) {
		nameVariables.prohibitedNames.forEach[
			if(ent.name.equalsIgnoreCase(it)) {
				error('Name ' + ent.name + ' is prohibited',
					CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME,
					PROHIBITED_NAME)
			}
		]
	}
	
	@Check
	// Los atributos no pueden tener ciertos nombres que ya se usan durante la generacion de codigo
	def checkNamesAttributeNotProhibited(Attribute att) {
		nameVariables.prohibitedNames.forEach[
			if(att.name.equalsIgnoreCase(it)) {
				error('Name ' + att.name + ' is prohibited',
					CodeGeneratorModelPackage.Literals.ATTRIBUTE__NAME,
					PROHIBITED_NAME)
			}
		]
	}
	
	@Check
	// Los servicios no pueden tener ciertos nombres que ya se usan durante la generacion de codigo
	def checkNamesServiceNotProhibited(Service ser) {
		nameVariables.prohibitedNames.forEach[
			if(ser.name.equalsIgnoreCase(it)) {
				error('Name ' + ser.name + ' is prohibited',
					CodeGeneratorModelPackage.Literals.SERVICE__NAME,
					PROHIBITED_NAME)
			}
		]
	}
	
	@Check
	// Las funciones Upload y Update (si existen) deben completarse (TODO)
	def checkToDo(Artifact artifact) {
		if(artifact.basicServices.contains(ServiceEnum.UPDATE) || artifact.basicServices.contains(ServiceEnum.UPLOAD) || artifact.basicServices.contains(ServiceEnum.ALL)) {
			val platformString = artifact.eResource.URI.toPlatformString(true)
			val rules_file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(platformString))
			val project = rules_file.project
			val file_json = project.getFile(new Path("src/main/java/" + names.getArtifactJsonFileStri(artifact) + ".java"))
			if(file_json.exists)
			{
				val scanner = new Scanner(file_json.contents)
				var int lineNumber = 0
				while(scanner.hasNextLine) {
					val line = scanner.nextLine
					lineNumber++
					if(line.contains("TODO")) {
						warning("You need to complete Update or Upload methods on package " + names.getArtifactJsonFileStri(artifact) + " line " + lineNumber,
		        			CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME,
		       				ARTIFACT_TODO)
					}
				}
				scanner.close
			}
		}
    }
    
    @Check
	// Las funciones de service deben completarse (TODO)
	def checkToDo(SimpleService service) {
		val platformString = service.eResource.URI.toPlatformString(true)
		val rules_file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(platformString))
		val project = rules_file.project
		val file_json = project.getFile(new Path("src/main/java/" + names.getServiceFileStri(service) + ".java"))
		if(file_json.exists)
		{
			val scanner = new Scanner(file_json.contents)
			var int lineNumber = 0
			while(scanner.hasNextLine) {
				val line = scanner.nextLine
				lineNumber++
				if(line.contains("TODO")) {
					warning("You need to complete Update or Upload methods on package " + names.getServiceFileStri(service) + " line " + lineNumber,
	        			CodeGeneratorModelPackage.Literals.SERVICE__NAME,
	       				SERVICE_TODO)
				}
			}
			scanner.close
		}
	}
	
	@Check
	// Es necesario al menos una mongoURI
	def checkMongoURI(Root root) {
		if(root.mongoURIs.empty) {
			warning("You need to set at least one MongoURI",
	        	CodeGeneratorModelPackage.Literals.ROOT__MONGO_UR_IS,
	       		EMPTY_MONGO_URI)
		}
	}
}
