/**
 * generated by Xtext
 */
package miso.distil.codeGenerator.validation;

import codeGeneratorModel.AbstractEntity;
import codeGeneratorModel.Artifact;
import codeGeneratorModel.Attribute;
import codeGeneratorModel.CodeGeneratorModelPackage;
import codeGeneratorModel.Entity;
import codeGeneratorModel.MultiAttribute;
import codeGeneratorModel.MultiService;
import codeGeneratorModel.OnService;
import codeGeneratorModel.Root;
import codeGeneratorModel.Service;
import codeGeneratorModel.ServiceEnum;
import codeGeneratorModel.SimpleService;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import miso.distil.codeGenerator.validation.AbstractRulesValidator;
import miso.distil.codeGenerator.validation.nameVariables;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * @author Carlos Carrascal
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class RulesValidator extends AbstractRulesValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String REPEATED_NAME = "repeatedName";
  
  public final static String REPEATED_SERVICE = "repeatedService";
  
  public final static String INPUT_WRONG = "wrongInput";
  
  public final static String INVALID_ATTR = "invalidAttribute";
  
  public final static String PROHIBITED_NAME = "prohibitedName";
  
  public final static String PROHIBITED_REFERENCE = "prohibitedReference";
  
  public final static String EMPTY_CLASS = "emptyObject";
  
  @Check
  public void chechOnService(final OnService onSer) {
    EList<ServiceEnum> _whenServices = onSer.getWhenServices();
    final Consumer<ServiceEnum> _function = (ServiceEnum it) -> {
      Artifact _artifact = onSer.getArtifact();
      EList<ServiceEnum> _basicServices = _artifact.getBasicServices();
      boolean _notEquals = (!Objects.equal(_basicServices, null));
      if (_notEquals) {
        Artifact _artifact_1 = onSer.getArtifact();
        EList<ServiceEnum> _basicServices_1 = _artifact_1.getBasicServices();
        boolean _contains = _basicServices_1.contains(it);
        boolean _not = (!_contains);
        if (_not) {
          Artifact _artifact_2 = onSer.getArtifact();
          String _name = _artifact_2.getName();
          String _plus = (" Artifact " + _name);
          String _plus_1 = (_plus + " does not have service ");
          String _string = it.toString();
          String _plus_2 = (_plus_1 + _string);
          String _plus_3 = (_plus_2 + " enabled");
          this.error(_plus_3, 
            CodeGeneratorModelPackage.Literals.ON_SERVICE__WHEN_SERVICES, 
            RulesValidator.PROHIBITED_REFERENCE);
        }
      }
    };
    _whenServices.forEach(_function);
  }
  
  @Check
  public void chechOnServiceRepeated(final OnService onSer) {
    EList<ServiceEnum> _whenServices = onSer.getWhenServices();
    final Consumer<ServiceEnum> _function = (ServiceEnum it) -> {
      EList<ServiceEnum> _whenServices_1 = onSer.getWhenServices();
      int _lastIndexOf = _whenServices_1.lastIndexOf(it);
      EList<ServiceEnum> _whenServices_2 = onSer.getWhenServices();
      int _indexOf = _whenServices_2.indexOf(it);
      boolean _notEquals = (_lastIndexOf != _indexOf);
      if (_notEquals) {
        String _string = it.toString();
        String _plus = ("Option " + _string);
        String _plus_1 = (_plus + " is repeated on positions ");
        EList<ServiceEnum> _whenServices_3 = onSer.getWhenServices();
        int _indexOf_1 = _whenServices_3.indexOf(it);
        String _plus_2 = (_plus_1 + Integer.valueOf(_indexOf_1));
        String _plus_3 = (_plus_2 + " and ");
        EList<ServiceEnum> _whenServices_4 = onSer.getWhenServices();
        int _lastIndexOf_1 = _whenServices_4.lastIndexOf(it);
        String _plus_4 = (_plus_3 + Integer.valueOf(_lastIndexOf_1));
        this.error(_plus_4, 
          CodeGeneratorModelPackage.Literals.ON_SERVICE__WHEN_SERVICES, 
          RulesValidator.REPEATED_SERVICE);
      }
    };
    _whenServices.forEach(_function);
  }
  
  @Check
  public void checkMultiAttNotRecursive(final Entity ent) {
    EList<Attribute> _attributes = ent.getAttributes();
    EList<MultiAttribute> atts = this.getAllNestedMultiAtts(_attributes);
    for (final MultiAttribute att : atts) {
      Entity _type = att.getType();
      String _name = _type.getName();
      String _name_1 = ent.getName();
      boolean _equalsIgnoreCase = _name.equalsIgnoreCase(_name_1);
      if (_equalsIgnoreCase) {
        String _name_2 = att.getName();
        String _plus = ("This entity contains " + _name_2);
        String _plus_1 = (_plus + ", who contains this entity");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME, 
          RulesValidator.PROHIBITED_REFERENCE);
      }
    }
  }
  
  private EList<MultiAttribute> getAllNestedMultiAtts(final EList<Attribute> atts) {
    final EList<MultiAttribute> list = new BasicEList<MultiAttribute>();
    final Consumer<Attribute> _function = (Attribute it) -> {
      if ((it instanceof MultiAttribute)) {
        Entity _type = ((MultiAttribute)it).getType();
        EList<Attribute> _attributes = _type.getAttributes();
        EList<MultiAttribute> _allNestedMultiAtts = this.getAllNestedMultiAtts(_attributes);
        list.addAll(_allNestedMultiAtts);
        list.add(((MultiAttribute)it));
      }
    };
    atts.forEach(_function);
    return list;
  }
  
  @Check
  public void checkMultiServiceParameters(final MultiService mulSer) {
    boolean _isParallel = mulSer.isParallel();
    boolean _not = (!_isParallel);
    if (_not) {
      EList<Service> _services = mulSer.getServices();
      Service _get = _services.get(0);
      EList<AbstractEntity> out = this.getOutput(((Service) _get));
      for (int j = 1; (j < mulSer.getServices().size()); j++) {
        {
          EList<Service> _services_1 = mulSer.getServices();
          Service service = ((EList<Service>) _services_1).get(j);
          int _size = out.size();
          EList<AbstractEntity> _input = this.getInput(service);
          int _size_1 = _input.size();
          boolean _notEquals = (_size != _size_1);
          if (_notEquals) {
            String _name = service.getName();
            String _plus = ("Service " + _name);
            String _plus_1 = (_plus + " requires ");
            EList<AbstractEntity> _input_1 = this.getInput(service);
            int _size_2 = _input_1.size();
            String _plus_2 = (_plus_1 + Integer.valueOf(_size_2));
            String _plus_3 = (_plus_2 + " inputs but receives ");
            int _size_3 = out.size();
            String _plus_4 = (_plus_3 + Integer.valueOf(_size_3));
            String _plus_5 = (_plus_4 + " from ");
            EList<Service> _services_2 = mulSer.getServices();
            Service _get_1 = ((EList<Service>) _services_2).get((j - 1));
            String _name_1 = _get_1.getName();
            String _plus_6 = (_plus_5 + _name_1);
            this.error(_plus_6, 
              CodeGeneratorModelPackage.Literals.MULTI_SERVICE__SERVICES, 
              RulesValidator.INPUT_WRONG);
          }
          for (int i = 0; (i < this.getInput(service).size()); i++) {
            AbstractEntity _get_2 = out.get(i);
            EList<AbstractEntity> _input_2 = this.getInput(service);
            AbstractEntity _get_3 = _input_2.get(i);
            boolean _equals = _get_2.equals(_get_3);
            boolean _not_1 = (!_equals);
            if (_not_1) {
              String _name_2 = service.getName();
              String _plus_7 = ((("Input " + Integer.valueOf(i)) + " of service ") + _name_2);
              String _plus_8 = (_plus_7 + " requires ");
              EList<AbstractEntity> _input_3 = this.getInput(service);
              AbstractEntity _get_4 = _input_3.get(i);
              String _name_3 = _get_4.getName();
              String _plus_9 = (_plus_8 + _name_3);
              String _plus_10 = (_plus_9 + " but ");
              AbstractEntity _get_5 = out.get(i);
              String _name_4 = _get_5.getName();
              String _plus_11 = (_plus_10 + _name_4);
              String _plus_12 = (_plus_11 + " given");
              this.error(_plus_12, 
                CodeGeneratorModelPackage.Literals.MULTI_SERVICE__SERVICES, 
                RulesValidator.INPUT_WRONG);
            }
          }
          EList<AbstractEntity> _output = this.getOutput(service);
          out = _output;
        }
      }
    }
  }
  
  private EList<AbstractEntity> getInput(final Service service) {
    if ((service instanceof SimpleService)) {
      return ((SimpleService)service).getInput();
    } else {
      if ((service instanceof MultiService)) {
        boolean _isParallel = ((MultiService)service).isParallel();
        if (_isParallel) {
          EList<AbstractEntity> input = new BasicEList<AbstractEntity>();
          EList<Service> _services = ((MultiService)service).getServices();
          for (final Service ser : ((EList<Service>) _services)) {
            EList<AbstractEntity> _input = this.getInput(ser);
            input.addAll(_input);
          }
          return input;
        } else {
          EList<Service> _services_1 = ((MultiService)service).getServices();
          Service _get = _services_1.get(0);
          return this.getInput(((Service) _get));
        }
      }
    }
    return null;
  }
  
  private EList<AbstractEntity> getOutput(final Service service) {
    if ((service instanceof SimpleService)) {
      return ((SimpleService)service).getOutput();
    } else {
      if ((service instanceof MultiService)) {
        boolean _isParallel = ((MultiService)service).isParallel();
        if (_isParallel) {
          EList<AbstractEntity> output = new BasicEList<AbstractEntity>();
          EList<Service> _services = ((MultiService)service).getServices();
          for (final Service ser : ((EList<Service>) _services)) {
            EList<AbstractEntity> _output = this.getOutput(ser);
            output.addAll(_output);
          }
          return output;
        } else {
          EList<Service> _services_1 = ((MultiService)service).getServices();
          Service _last = IterableExtensions.<Service>last(_services_1);
          return this.getOutput(((Service) _last));
        }
      }
    }
    return null;
  }
  
  @Check
  public void checkEntityStartsWithCapital(final AbstractEntity ent) {
    String _name = ent.getName();
    char _charAt = _name.charAt(0);
    boolean _isUpperCase = Character.isUpperCase(_charAt);
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.error("Identifier should start with a capital", 
        CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME, 
        RulesValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkAttributeStartsWithLower(final Attribute att) {
    String _name = att.getName();
    char _charAt = _name.charAt(0);
    boolean _isLowerCase = Character.isLowerCase(_charAt);
    boolean _not = (!_isLowerCase);
    if (_not) {
      this.error("Identifier should start with a low case", 
        CodeGeneratorModelPackage.Literals.ATTRIBUTE__NAME, 
        RulesValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkServiceStartsWithLower(final Service ser) {
    String _name = ser.getName();
    char _charAt = _name.charAt(0);
    boolean _isUpperCase = Character.isUpperCase(_charAt);
    boolean _not = (!_isUpperCase);
    if (_not) {
      this.error("Identifier should start with a capital", 
        CodeGeneratorModelPackage.Literals.SERVICE__NAME, 
        RulesValidator.INVALID_NAME);
    }
  }
  
  @Check
  public void checkArtifactDontRepeatBasicServices(final Artifact art) {
    final List<ServiceEnum> services = new ArrayList<ServiceEnum>();
    EList<ServiceEnum> _basicServices = art.getBasicServices();
    for (final ServiceEnum service : ((EList<ServiceEnum>) _basicServices)) {
      boolean _contains = services.contains(service);
      if (_contains) {
        String _name = service.getName();
        String _plus = (_name + " is repeated");
        this.error(_plus, 
          CodeGeneratorModelPackage.Literals.ARTIFACT__BASIC_SERVICES, 
          RulesValidator.REPEATED_SERVICE);
      } else {
        services.add(service);
      }
    }
  }
  
  @Check
  public void checkUniqueNames(final Root root) {
    final List<String> names = new ArrayList<String>();
    EList<Artifact> _artifacts = root.getArtifacts();
    final Consumer<Artifact> _function = (Artifact it) -> {
      String _name = it.getName();
      boolean _contains = names.contains(_name);
      if (_contains) {
        String _name_1 = it.getName();
        String _plus = ("Name " + _name_1);
        String _plus_1 = (_plus + " is repeated");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.ROOT__ARTIFACTS, 
          RulesValidator.REPEATED_NAME);
      } else {
        String _name_2 = it.getName();
        String _lowerCase = _name_2.toLowerCase();
        names.add(_lowerCase);
      }
      EList<Attribute> _attributes = it.getAttributes();
      final Consumer<Attribute> _function_1 = (Attribute it_1) -> {
        String _name_3 = it_1.getName();
        boolean _contains_1 = names.contains(_name_3);
        if (_contains_1) {
          String _name_4 = it_1.getName();
          String _plus_2 = ("Name " + _name_4);
          String _plus_3 = (_plus_2 + " is repeated");
          this.error(_plus_3, 
            CodeGeneratorModelPackage.Literals.ROOT__ARTIFACTS, 
            RulesValidator.REPEATED_NAME);
        } else {
          String _name_5 = it_1.getName();
          String _lowerCase_1 = _name_5.toLowerCase();
          names.add(_lowerCase_1);
        }
      };
      ((EList<Attribute>) _attributes).forEach(_function_1);
    };
    ((EList<Artifact>) _artifacts).forEach(_function);
    EList<Entity> _entities = root.getEntities();
    final Consumer<Entity> _function_1 = (Entity it) -> {
      String _name = it.getName();
      boolean _contains = names.contains(_name);
      if (_contains) {
        String _name_1 = it.getName();
        String _plus = ("Name " + _name_1);
        String _plus_1 = (_plus + " is repeated");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.ROOT__ENTITIES, 
          RulesValidator.REPEATED_NAME);
      } else {
        String _name_2 = it.getName();
        String _lowerCase = _name_2.toLowerCase();
        names.add(_lowerCase);
      }
      EList<Attribute> _attributes = it.getAttributes();
      final Consumer<Attribute> _function_2 = (Attribute it_1) -> {
        String _name_3 = it_1.getName();
        boolean _contains_1 = names.contains(_name_3);
        if (_contains_1) {
          String _name_4 = it_1.getName();
          String _plus_2 = ("Name " + _name_4);
          String _plus_3 = (_plus_2 + " is repeated");
          this.error(_plus_3, 
            CodeGeneratorModelPackage.Literals.ROOT__ENTITIES, 
            RulesValidator.REPEATED_NAME);
        } else {
          String _name_5 = it_1.getName();
          String _lowerCase_1 = _name_5.toLowerCase();
          names.add(_lowerCase_1);
        }
      };
      ((EList<Attribute>) _attributes).forEach(_function_2);
    };
    ((EList<Entity>) _entities).forEach(_function_1);
    EList<Service> _services = root.getServices();
    final Consumer<Service> _function_2 = (Service it) -> {
      String _name = it.getName();
      boolean _contains = names.contains(_name);
      if (_contains) {
        String _name_1 = it.getName();
        String _plus = ("Name " + _name_1);
        String _plus_1 = (_plus + " is repeated");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.ROOT__SERVICES, 
          RulesValidator.REPEATED_NAME);
      } else {
        String _name_2 = it.getName();
        String _lowerCase = _name_2.toLowerCase();
        names.add(_lowerCase);
      }
    };
    ((EList<Service>) _services).forEach(_function_2);
  }
  
  @Check
  public void checkNamesEntityNotProhibited(final AbstractEntity ent) {
    final Consumer<String> _function = (String it) -> {
      String _name = ent.getName();
      boolean _equalsIgnoreCase = _name.equalsIgnoreCase(it);
      if (_equalsIgnoreCase) {
        String _name_1 = ent.getName();
        String _plus = ("Name " + _name_1);
        String _plus_1 = (_plus + " is prohibited");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.ABSTRACT_ENTITY__NAME, 
          RulesValidator.PROHIBITED_NAME);
      }
    };
    nameVariables.prohibitedNames.forEach(_function);
  }
  
  @Check
  public void checkNamesAttributeNotProhibited(final Attribute att) {
    final Consumer<String> _function = (String it) -> {
      String _name = att.getName();
      boolean _equalsIgnoreCase = _name.equalsIgnoreCase(it);
      if (_equalsIgnoreCase) {
        String _name_1 = att.getName();
        String _plus = ("Name " + _name_1);
        String _plus_1 = (_plus + " is prohibited");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.ATTRIBUTE__NAME, 
          RulesValidator.PROHIBITED_NAME);
      }
    };
    nameVariables.prohibitedNames.forEach(_function);
  }
  
  @Check
  public void checkNamesServiceNotProhibited(final Service ser) {
    final Consumer<String> _function = (String it) -> {
      String _name = ser.getName();
      boolean _equalsIgnoreCase = _name.equalsIgnoreCase(it);
      if (_equalsIgnoreCase) {
        String _name_1 = ser.getName();
        String _plus = ("Name " + _name_1);
        String _plus_1 = (_plus + " is prohibited");
        this.error(_plus_1, 
          CodeGeneratorModelPackage.Literals.SERVICE__NAME, 
          RulesValidator.PROHIBITED_NAME);
      }
    };
    nameVariables.prohibitedNames.forEach(_function);
  }
}
